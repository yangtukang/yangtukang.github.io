---
title: 数据库
date: 2023-06-18 19:14:36
tags:
---

# 数据库

## 基本概念

1.   数据库具有永久存储、有组织和可共享三个基本特点。
2.   DDL（Data Definition Language）：数据定义语言 ，包括定义数据库中的对象，如表、视图、存储过程等。
3.   DML（Data Manipulation Language）：数据操作语言，包括对数据库数据的插入、删除和更改操作。
4.   DQL（Data Query Language）：数据查询语言，包括对数据库数据的查询操作。
5.   DCL（Data Control Language）：数据控制语言，用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据尽心监视等。

## 实体–联系模型

实体—联系方法使用的工具称为E-R图，他所描述的现实世界的信息结构称为企业模式，也把这种描述称为E-R模型。

1.   实体

     实体具有公共属性，并可相互区分的实现世界对象的集合。

     实体中每个具体的记录纸（一行数据），称之为实体的一个实例。

     在E-R图中用矩形表示具体的实体，把实体名写在框内。

2.   属性

     每个实体都具有一定的特征或性质

     属性是描述实体或者联系的性质或特征的数据项，属于一个实体的所有实例都具有相同的性质。

     在实体的属性中，将能够唯一标识实体的一个属性或最小的一组属性（称为属性集或属性组）称为实体的标识属性，这个属性或属性组也称为实体的码。

     在E-R图中用圆角矩形表示，在圆角矩形框内写上属性的名字，并用连线将属性框与它所描述的实体联系起来。

3.   联系

     在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界反应为实体内部的联系和实体之间的联系。实体内部的联系通常是指一个实体内部属性之间的联系，实体之间的联系通常是指不通实体之间的联系。

     联系是数据之间的关联关系，在E-R图中，联系用菱形框表示，框内写上联系名，并用连线将联系框与它所关联的实体连接起来。

     1.   一对一联系(1:1): 如果实体A中的每个实例在实体B中至多有一个（也可以没有）实例与之关联，反之亦然，则称实体A与实体B具有一对一联系，记作1:1。
     2.   一对多联系(1:n): 如果实体A中的每个实例在实体B中有n个实例（n>=0）与之关联，而实体B中每个实例在实体A中最多只有一个实例与之关联，则称实体A与实体B是一对多联系。
     3.   多对多联系(m:n): 如果实体A中每个实例在实体B中有n个实例（n>=0）与之关联，而实体B中的每个实例，在实体A中也有m个实例（m>=0）与之关联，则称实体A与实体B是多对多联系，记为m:n。

## 关系模型的基本术语与形式化定义

### 基本术语

1.   关系

     通俗来讲，关系就是二维表，二维表的名字就是关系的名字。

2.   属性

     二维表中的每个列称为一个属性，每个属性有一个名字，称为属性名。二维表中对应某一列的值为属性值；二维表中列的个数称为关系的元组。如果一个二维表有n个列，则称其为n元关系。

3.   值域

     二维表中属性的取值范围称为值域。

4.   元组

     二维表中一行数据称为一个元组。

5.   分量

     元组中的每一个属性称为元组的一个分量，n元关系的每个元组有n个分量。

6.   关系模式

     二维表的结构称为关系模式，或者说关系模式就是二维表框架或表头结构。

7.   关系数据库

     对应于一个关系型数据库的所有关系的集合称为关系型数据库。

8.   候选键

     如果一个属性或属性集的值能够唯一标识一个关系的元组而又不包括多余的属性，则称该属性或属性集为候选键。

9.   主键

     当一个关系中有多个候选键时，可以从中选择一个作为主键。

10.   主属性和非主属性

      包含在任意候选键中的属性称为主属性（至少有一个）。不包含在任意候选键中的属性称为非主属性。

| 关系术语 |      一般的表格术语      |
| :------: | :----------------------: |
|  关系名  |           表名           |
| 关系模式 | 表头（表所包含列的描述） |
|   关系   |      （一张）二维表      |
|   元组   |         记录或行         |
|   属性   |            列            |
|   分量   |   一条记录中某个列的值   |

## 完整性约束

### 实体完整性

实体完整性是保证关系中每个元组都是可识别和唯一的。

实体完整性是指关系数据库中所有的表都必须有主键，而且表中不允许存在以下记录。

1.   无主键值的记录
2.   主键值相同的记录

### 参照完整性

参照完整性也称为引用完整性，在关系模型中，实体以及实体之间的联系都是用关系来表示的，这样就自然存在着关系与关系之间的引用。

进一步定义外键：

定义：设F是关系R的一个或一组属性，如果F与关系S的主键相对应，则称F是关系R的外键，并称关系R为参照关系或目的关系。关系R为被参照关系或目的关系。关系R和关系S不一定是不同的关系。

### 用户定义的完整性

用户定义的完整性也称为域完整性或语义完整性。

用户定义的完整性实际上就是指明观秀中属性的取值范围，也就是属性的域，这样可以限制关系中属性的取值类型及取值范围，防止属性的值与应用的寓意矛盾。例如，学生考试成绩的取值范围为0～100，或取（优、良、中、及格、不及格）。

## 索引

### 索引的基本概念

在数据库中建立索引是为了加快数据的查询速度。数据库中的索引与书籍中目录或书后的术语表类似。在数据库中，索引使对数据的查找不需要对整个表进行扫描，就可以在其中找到所需的数据。数据库中的索引是一个表中所包含的列值的列表，其中注明了表中包含各个值的行数据所在的存储位置。可以为表中的单个列建立索引，也可以为一组列建立索引。

### 聚集索引（聚簇索引）

聚集索引对数据按索引关键字值进行物理排序。

聚集索引的关键字决定了数据在表中的物理存储顺序，因此一个表中只能包含一个聚集索引。但是该索引可以由多个列（组合索引）组成。

### 非聚集索引（非聚簇索引 ）

非聚集索引不对数据按索引关键字值进行物理排序，而只将索引关键字按值进行排序。

非聚集索引并不改变数据的物理存储顺序，可以在一个表上建立多个非聚集索引。

### 唯一索引

唯一索引用于确保索引列不包含重复的值。唯一索引可以值包含一个列（限制该列取值不重复），也可以由多个列共同构成（限制这些列的组合取值不重复）。

聚集索引和非聚集索引都可以是唯一索引。只要列中的数据是唯一的，就可以在同一个表上创建一个唯一的聚集索引和多个唯一的非聚集索引。

只有当数据本身具有唯一特征时，指定唯一索引才有意义。

## 视图

通常将模式对应的表称为基本表，基本表中的数据实际上是物理存储在磁盘上的。

视图是由数据库的基本表中选取出来的数据组成的逻辑窗口，是基本表的部分行和列数据的组合。

视图是一个虚表，数据库中只存储视图的定义，而不存储视图所包含的数据，这些数据仍存放在原来的基本表中。

### 使用视图的好处：

1.   视图数据始终与基本表数据保持一致。当基本表中的数据发生变化时，从视图中查询出的数据也会随之变化。

2.   节省存储空间。当数据量非常大时，重复存储数据是非常耗费空间的。

视图可以从一个基本表中提取数据，也可以从多个基本表中提取数据，甚至还可以从其他视图中提取数据，构成新的视图。

## 范式

### 函数依赖

公式 Y=f(X) 中给定一个X值，都会得到一个Y值和它对应。X函数决定Y，或Y函数依赖于X，表示为X->Y。

1.   如果X->Y。但Y不包含于X，则称X->Y是非平凡的函数依赖。
2.   如果Y函数不依赖于X，则记作X$\nrightarrow $Y。
3.   如果X->Y，则称X为决定因子。
4.   如果X->Y，并且Y->X，则记作X<->Y。
5.   如果X->Y，并且对于X的一个任意真子集X‘都有X'$\nrightarrow $Y，则称Y完全函数依赖于X，如果X’->Y成立，则称Y部分函数依赖于X
6.   如果X->Y、Y->Z，则称Z传递函数依赖于X。

### 第一范式

第一范式是必须的，后续的其他范式是可选的。

**定义：**不包含非原子项属性的关系是第一范式（1NF）的关系。

### 第二范式

第二范式属于完全函数依赖的概念。

#### 完全函数依赖：

假设A和B是某个关系中的属性组，如果B函数依赖于A，但不函数依赖于A的任一真子集，则称B完全函数依赖于A。即对于函数依赖A->B，如果移除A中的任一属性都使得这种函数依赖关系不存在，则A->B就是一个完全函数依赖。如果移除A中的某个或某些属性，这个函数依赖仍然成立，那么A->B就是一个部分函数依赖。

**定义：**如果R(U,F)$\in$1NF，并且R中的每个非主属性都完全函数依赖于主键，则R(U,F)$\in$2NF。

由定义可以看出，若某个第一范式关系的主键只有一个列组成，则这个关系就是第二范式关系。但如果某个第一范式关系的主键是由多个属性共同构成的复合主键，并且存在非主属性对主属性的部分函数依赖，则这个关系就不是第二范式关系。

### 第三范式

**定义：**如果R(U,F)$\in$2NF，并且所有的非主属性都不传递依赖于主键，则R(U,F)$\in$3NF。

从定义可以看出，如果存在非主属性对主键的传递函数依赖，则对应的关系模式就不是第三范式的。

## 事务

事务时数据库处理的一个逻辑工作单元，由用户业务定义的一个或多个访问数据库的操作组成，这些操作一般包含检索（读）、插入（写）、删除和修改数据。一个事务内的所有语句被作为一个整体，要么全部执行，要么全部不执行。事务可以嵌入到应用程序中，也可以通过SQL语句交互地指定。

事务具有4个特性：**原子性**、**一致性**、**隔离性**和**持久性**。

### 原子性

事务的原子性是指事务是数据库的一个单一的、独立的逻辑工作单位，事务中的操作要么都做，要么都不做

### 一致性

事务的一致性是指事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。

### 隔离性

事务的隔离性是指数据库中一个事务的执行不能被其他事务干扰，即一个 事务内部的操作及使用的数据对其他事务是隔离的，并发执行的各个事务之间不能相互干扰。

### 持久性

事务的持久性也称为永久性，是指事务一旦提交，则其对数据库中数据的改变就是永久的，以后的操作或故障不会对事务的操作产生任何影响。

事务是数据库并发控制和恢复的基本单位。保证事务的ACID特性是事务处理的重要任务 。

事务ACID特性可能遭到破坏的因素有：

1.   多个事务并行运行时，不同事务的操作有交叉情况。

     数据库管理系统必须保证多个事务在交叉运行时不影响这些事务的其他原子性。

2.   事务在运行过程中被迫停止。

     数据库管理系统必须保证被强迫终止的事务对数据库和其他事务没有任何影响。

### 事务处理模型

美国标准化组织（ANSI）给出了管理数据库事务的定义，有两个SQL语句用来提供对事务的支持，它们时**COMMIT**和**ROLLBACK**。ANSI标准要求当用户或者应用程序开始一个事务序列后，他必须连续地执行全部的SQL语句，直到出现下列4个事件之一。

*   到达了一个**COMMIT**语句。这种情况下，事务进行的所有更改都被永久地保存到数据库中。**COMMIT**语句自动结束一个事务并表明成功地完成了事务。
*   到达了一个**ROLLBACK**语句。这种情况下，事务进行的所有更改都夭折了，并且数据库被回滚到之前的一个一致性状态。**ROLLBACK**操作没有成功地完成事务。
*   成功地到达了程序的结束。这种情况下，事务进行的所有更改都被永久记录到数据库中。这个活动等同于**COMMIT**。
*   程序被异常终止了。这种情况下，事务进行的所有对数据库的更改都被终止，而且数据库被回滚到它之前的一个一致性状态。这个活动等同于**ROLLBACK**。

## 并发控制

数据库系统一个明显的特点是多个用户共享数据库资源，尤其是多用户可以同时存储相同的数据。火车订票系统的数据库、银行系统的数据库等都是典型的多用户共享的数据库。在这样的系统中，统一时刻同时运行的事务可达数百个。若对多用户的并发控制不加控制，就会造成数据存、取错误，破坏数据的一致性和完整性。

如果事务是顺序执行的，即一个事务完成后，再开始另一个事务，则称这种执行方式为串行执行。

![串行执行.drawio](https://ytk-imgs.oss-rg-china-mainland.aliyuncs.com/imgs1202306191139716.png)

如果数据库管理系统可以同时接受多个事务，并且这些事务在时间上可以重叠执行，则称这种执行方式为并发执行。在单CPU系统中，同一时间只能有一个事务占据CPU，哥哥事务交叉地使用CPU，这种并发方式称之为交叉并发。在多CPU系统中，多个事务可以同时占有CPU，这种并发方式称为同时并发。

![交叉并行执行.drawio](https://ytk-imgs.oss-rg-china-mainland.aliyuncs.com/imgs1202306191138360.png)

1.   丢失数据修改（两次修改）

     丢失数据修改是指两个事务T1和T2读入同一数据进行修改 ，T2提交的结果破坏了T1提交的结果，导致T1的修改被T2覆盖掉了。

2.   读”脏”数据（读恢复前的数据）

     读“脏数据”是指一个事务读到了某个失败事务运行过程中的数据，即事务T1修改了某一数据，并将修改结果写回到磁盘，然后事务T2读取了同一个数据（T1修改后的结果），但T1后来由于某种原因撤销了它所做的操作，这样被T1修改过的数据又恢复为原来的值，那么，T2读到的值就与数据库中实际的数据值不一致了。这时就说T2读的数据为T1的“脏”数据，或不正确的数据。

3.   不可重复读（不一致的索引，两次读数据不一样）

     不可重复读是指事务T1读取数据后，事务T2执行了更新操作，修改了T1读取的数据，T1操作完数据后，又重亲读取了同样的数据，但这次读完后，当T1再对这些数据进行相同操作时，所得的结果与前一次不一样。

4.   产生“幽灵”数据（读了被删除的数据）

     产生“幽灵”数据实际属于不可重复读的范畴。它是指当事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中的部分记录，或者在其中添加了部分记录，那么，当T1在此按相同条件读取数据时，发现其中莫名其妙地少了（删除）或多了（插入）一些记录。这样的数据对T1来说就是”幽灵“数据或”幻影“数据。

### 乐观锁

​	乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新时判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。

### 悲观锁

​	悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，知道操作完成后才会释放锁；上锁期间别人不能修改数据。
